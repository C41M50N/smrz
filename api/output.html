<html><body><div><div class="mt-12 prose-sm lg:pr-24 md:prose-md text-white/60 sm:mx-6 prose-strong:text-white/90 prose-code:text-white/80 prose-code:bg-white/10 prose-code:px-2 prose-code:py-1 prose-code:border-white/20 prose-code:rounded-md prose-pre:p-0 prose-pre:m-0 prose-pre:leading-6"><div class="text-center"><p class="text-lg font-normal leading-8 text-left text-white/60">TLDR: Please don't do this:</p></div>
<div class="flex flex-col bg-gradient-to-t from-[rgba(255,255,255,0.1)] to-[rgba(255,255,255,0.07)] rounded-[20px] border-[.5px] border-[rgba(255,255,255,0.1)] not-prose text-[0.8125rem] p-4"><p class="flex flex-row justify-end gap-4 mt-2 mr-4 border-white/10"></p><div class="flex items-center justify-between"><pre highlighter="hljs"><code class="language-bash"><span>https://company.com/resource/c6b10dd3-1dcf-416c-8ed8-ae561807fcaf</span></code></pre></div></div>
<hr>
<h2 id="the-baseline-ensuring-global-uniqueness" class="text-2xl font-medium leading-8 blog-heading-gradient text-white/60 scroll-mt-20">The baseline: Ensuring global uniqueness</h2>
<p class="text-lg font-normal leading-8 text-left text-white/60">Unique identifiers are essential for distinguishing individual entities within a system. They provide a reliable way to ensure that each item, user, or piece of data has a unique identity. By maintaining uniqueness, applications can effectively manage and organize information, enabling efficient operations and facilitating data integrity.</p>
<p class="text-lg font-normal leading-8 text-left text-white/60">Let’s not pretend like we are Google or AWS who have special needs around this. Any securely generated UUID with 128 bits is more than enough for us. There are lots of libraries that generate one, or you could fall back to the standard library of your language of choice. In this blog, I'll be using Typescript examples, but the underlying ideas apply to any language.</p>
<div class="flex flex-col bg-gradient-to-t from-[rgba(255,255,255,0.1)] to-[rgba(255,255,255,0.07)] rounded-[20px] border-[.5px] border-[rgba(255,255,255,0.1)] not-prose text-[0.8125rem] pl-4 pb-4"><div class="flex "><pre highlighter="hljs"><code class="language-typescript"><span>const</span><span> id = crypto.randomUUID();
</span><span></span><span>// '5727a4a4-9bba-41ae-b7fe-e69cf60bb0ab'</span></code></pre></div></div>
<p class="text-lg font-normal leading-8 text-left text-white/60">Stopping here is an option, but let's take the opportunity to enhance the user experience with small yet effective iterative changes:</p>
<ol class="flex flex-col list-decimal pl-6 text-white">
<li class="pl-6 leading-8 font-normal sm:text-lg text-white/60"><span class="text-lg">Make them easy to copy</span></li>
<li class="pl-6 leading-8 font-normal sm:text-lg text-white/60"><span class="text-lg">Prefixing</span></li>
<li class="pl-6 leading-8 font-normal sm:text-lg text-white/60"><span class="text-lg">More efficient encoding</span></li>
<li class="pl-6 leading-8 font-normal sm:text-lg text-white/60"><span class="text-lg">Changing the length</span></li>
</ol>
<h3 id="copying-uuids-is-annoying" class="text-xl font-medium leading-8 blog-heading-gradient text-white/60 scroll-mt-20">Copying UUIDs is annoying</h3>
<p class="text-lg font-normal leading-8 text-left text-white/60">Try copying this UUID by double-clicking on it:</p>
<div class="flex flex-col bg-gradient-to-t from-[rgba(255,255,255,0.1)] to-[rgba(255,255,255,0.07)] rounded-[20px] border-[.5px] border-[rgba(255,255,255,0.1)] not-prose text-[0.8125rem] p-4"><p class="flex flex-row justify-end gap-4 mt-2 mr-4 border-white/10"></p><div class="flex items-center justify-between"><pre highlighter="hljs"><code class="language-bash"><span>c6b10dd3-1dcf-416c-8ed8-ae561807fcaf</span></code></pre></div></div>
<p class="text-lg font-normal leading-8 text-left text-white/60">If you're lucky, you got the entire UUID but for most people, they got a single section. One way to enhance the usability of unique identifiers is by making them easily copyable. This can be achieved by removing the hyphens from the UUIDs, allowing users to simply double-click on the identifier to copy it. By eliminating the need for manual selection and copy-pasting, this small change can greatly improve the user experience when working with identifiers.</p>
<p class="text-lg font-normal leading-8 text-left text-white/60">Removing the hyphens is probably trivial in all languages, here’s how you can do it in js/ts:</p>
<div class="flex flex-col bg-gradient-to-t from-[rgba(255,255,255,0.1)] to-[rgba(255,255,255,0.07)] rounded-[20px] border-[.5px] border-[rgba(255,255,255,0.1)] not-prose text-[0.8125rem] pl-4 pb-4"><div class="flex "><pre highlighter="hljs"><code class="language-typescript"><span>const</span><span> id = crypto.randomUUID().replace(</span><span class="hljs-regexp">/-/g</span><span>, </span><span>""</span><span>);
</span><span></span><span>// fe4723eab07f408384a2c0f051696083</span></code></pre></div></div>
<p class="text-lg font-normal leading-8 text-left text-white/60">Try copying it now, it’s much nicer!</p>
<h3 id="prefixing" class="text-xl font-medium leading-8 blog-heading-gradient text-white/60 scroll-mt-20">Prefixing</h3>
<p class="text-lg font-normal leading-8 text-left text-white/60">Have you ever accidentally used a production API key in a development environment? I have, and it’s not fun.
We can help the user differentiate between different environments or resources within the system by adding a meaningful prefix. For example, Stripe uses prefixes like <code class="px-2 py-1 font-medium text-gray-600 border border-gray-200 rounded-md bg-gray-50 before:hidden after:hidden">sk_live_</code> for production environment secret keys or <code class="px-2 py-1 font-medium text-gray-600 border border-gray-200 rounded-md bg-gray-50 before:hidden after:hidden">cus_</code> for customer identifiers. By incorporating such prefixes, we can ensure clarity and reduce the chances of confusion, especially in complex systems where multiple environments coexist.</p>
<div class="flex flex-col bg-gradient-to-t from-[rgba(255,255,255,0.1)] to-[rgba(255,255,255,0.07)] rounded-[20px] border-[.5px] border-[rgba(255,255,255,0.1)] not-prose text-[0.8125rem] pl-4 pb-4"><div class="flex "><pre highlighter="hljs"><code class="language-typescript"><span>const</span><span> id = </span><span>`hello_</span><span>${crypto.randomUUID().replace(</span><span class="hljs-regexp">/-/g</span><span>, </span><span>""</span><span>)}</span><span>`</span><span>;
</span><span></span><span>// hello_1559debea64142f3b2d29f8b0f126041</span></code></pre></div></div>
<p class="text-lg font-normal leading-8 text-left text-white/60">Naming prefixes is an art just like naming variables. You want to be descriptive but be as short as possible. I'll share ours further down.</p>
<h3 id="encoding-in-base58" class="text-xl font-medium leading-8 blog-heading-gradient text-white/60 scroll-mt-20">Encoding in base58</h3>
<p class="text-lg font-normal leading-8 text-left text-white/60">Instead of using a hexadecimal representation for identifiers, we can also consider encoding them more efficiently, such as base58. Base58 encoding uses a larger character set and avoids ambiguous characters, such as upper case <code class="px-2 py-1 font-medium text-gray-600 border border-gray-200 rounded-md bg-gray-50 before:hidden after:hidden">I</code> and lower case <code class="px-2 py-1 font-medium text-gray-600 border border-gray-200 rounded-md bg-gray-50 before:hidden after:hidden">l</code> resulting in shorter identifier strings without compromising readability.</p>
<p class="text-lg font-normal leading-8 text-left text-white/60">As an example, an 8-character long base58 string, can store roughly 30.000 times as many states as an 8-char hex string. And at 16 chars, the base58 string can store 889.054.070 as many combinations.</p>
<p class="text-lg font-normal leading-8 text-left text-white/60">You can probably still do this with the standard library of your language but you could also use a library like <a href="https://github.com/ai/nanoid" aria-label="Link" class="text-left text-white underline hover:text-white/60">nanoid</a> which is available for most languages.</p>
<div class="flex flex-col bg-gradient-to-t from-[rgba(255,255,255,0.1)] to-[rgba(255,255,255,0.07)] rounded-[20px] border-[.5px] border-[rgba(255,255,255,0.1)] not-prose text-[0.8125rem] pl-4 pb-4"><div class="flex "><pre highlighter="hljs"><code class="language-typescript"><span>import</span><span> { customAlphabet } </span><span>from</span><span> </span><span>"nanoid"</span><span>;
</span><span></span><span>export</span><span> </span><span>const</span><span> nanoid = customAlphabet(
</span><span>  </span><span>"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"</span><span>,
</span>);

<span></span><span>const</span><span> id = </span><span>`prefix_</span><span>${nanoid(</span><span>22</span><span>)}</span><span>`</span><span>;
</span><span></span><span>// prefix_KSPKGySWPqJWWWa37RqGaX</span></code></pre></div></div>
<p class="text-lg font-normal leading-8 text-left text-white/60">We generated a 22 character long ID here, which can encode ~100x as many states as a UUID while being 10 characters shorter.</p>
<table><thead><tr class="border-b-[.75px] border-white/10 text-left"><th class="pb-4 text-base font-semibold text-left text-white"></th><th class="pb-4 text-base font-semibold text-left text-white">Characters</th><th class="pb-4 text-base font-semibold text-left text-white">Length</th><th class="pb-4 text-base font-semibold text-left text-white">Total States</th></tr></thead><tbody><tr class="border-b-[.75px] border-white/10 text-left"><td class="py-4 text-base font-normal text-left text-white/70">UUID</td><td class="py-4 text-base font-normal text-left text-white/70">16</td><td class="py-4 text-base font-normal text-left text-white/70">32</td><td class="py-4 text-base font-normal text-left text-white/70">2^122 = 5.3e+36</td></tr><tr class="border-b-[.75px] border-white/10 text-left"><td class="py-4 text-base font-normal text-left text-white/70">Base58</td><td class="py-4 text-base font-normal text-left text-white/70">58</td><td class="py-4 text-base font-normal text-left text-white/70">22</td><td class="py-4 text-base font-normal text-left text-white/70">58^22 = 6.2e+38</td></tr></tbody></table>
<p class="text-lg font-normal leading-8 text-left text-white/60"><em>The more states, the higher your collision resistance is because it takes more generations to generate the same ID twice (on average and if your algorithm is truly random)</em></p>
<h3 id="changing-the-entropy" class="text-xl font-medium leading-8 blog-heading-gradient text-white/60 scroll-mt-20">Changing the entropy</h3>
<p class="text-lg font-normal leading-8 text-left text-white/60">Not all identifiers need to have a high level of collision resistance. In some cases, shorter identifiers can be sufficient, depending on the specific requirements of the application. By reducing the entropy of the identifiers, we can generate shorter IDs while still maintaining an acceptable level of uniqueness.</p>
<p class="text-lg font-normal leading-8 text-left text-white/60">Reducing the length of your IDs can be nice, but you need to be careful and ensure your system is protected against ID collissions. Fortunately, this is pretty easy to do in your database layer. In our MySQL database we use IDs mostly as primary key and the database protects us from collisions. In case an ID exists already, we just generate a new one and try again. If our collision rate would go up significantly, we could simply increase the length of all future IDs and we’d be fine.</p>
<table><thead><tr class="border-b-[.75px] border-white/10 text-left"><th class="pb-4 text-base font-semibold text-left text-white">Length</th><th class="pb-4 text-base font-semibold text-left text-white">Example</th><th class="pb-4 text-base font-semibold text-left text-white">Total States</th></tr></thead><tbody><tr class="border-b-[.75px] border-white/10 text-left"><td class="py-4 text-base font-normal text-left text-white/70">nanoid(8)</td><td class="py-4 text-base font-normal text-left text-white/70">re6ZkUUV</td><td class="py-4 text-base font-normal text-left text-white/70">1.3e+14</td></tr><tr class="border-b-[.75px] border-white/10 text-left"><td class="py-4 text-base font-normal text-left text-white/70">nanoid(12)</td><td class="py-4 text-base font-normal text-left text-white/70">pfpPYdZGbZvw</td><td class="py-4 text-base font-normal text-left text-white/70">1.4e+21</td></tr><tr class="border-b-[.75px] border-white/10 text-left"><td class="py-4 text-base font-normal text-left text-white/70">nanoid(16)</td><td class="py-4 text-base font-normal text-left text-white/70">sFDUZScHfZTfkLwk</td><td class="py-4 text-base font-normal text-left text-white/70">1.6e+28</td></tr><tr class="border-b-[.75px] border-white/10 text-left"><td class="py-4 text-base font-normal text-left text-white/70">nanoid(24)</td><td class="py-4 text-base font-normal text-left text-white/70">u7vzXJL9cGqUeabGPAZ5XUJ6</td><td class="py-4 text-base font-normal text-left text-white/70">2.1e+42</td></tr><tr class="border-b-[.75px] border-white/10 text-left"><td class="py-4 text-base font-normal text-left text-white/70">nanoid(32)</td><td class="py-4 text-base font-normal text-left text-white/70">qkvPDeH6JyAsRhaZ3X4ZLDPSLFP7MnJz</td><td class="py-4 text-base font-normal text-left text-white/70">2.7e+56</td></tr></tbody></table>
<h2 id="conclusion" class="text-2xl font-medium leading-8 blog-heading-gradient text-white/60 scroll-mt-20">Conclusion</h2>
<p class="text-lg font-normal leading-8 text-left text-white/60">By implementing these improvements, we can enhance the usability and efficiency of unique identifiers in our applications. This will provide a better experience for both users and developers, as they interact with and manage various entities within the system. Whether it's copying identifiers with ease, differentiating between different environments, or achieving shorter and more readable identifier strings, these strategies can contribute to a more user-friendly and robust identification system.</p>
<h2 id="ids-and-keys-at-unkey" class="text-2xl font-medium leading-8 blog-heading-gradient text-white/60 scroll-mt-20">IDs and keys at Unkey</h2>
<p class="text-lg font-normal leading-8 text-left text-white/60">Lastly, I'd like to share our implementation here and how we use it in our <a href="https://github.com/unkeyed/unkey/blob/main/internal/id/src/index.ts" aria-label="Link" class="text-left text-white underline hover:text-white/60">codebase</a>. We use a simple function that takes a typed prefix and then generates the ID for us. This way we can ensure that we always use the same prefix for the same type of ID. This is especially useful when you have multiple types of IDs in your system.</p>
<div class="flex flex-col bg-gradient-to-t from-[rgba(255,255,255,0.1)] to-[rgba(255,255,255,0.07)] rounded-[20px] border-[.5px] border-[rgba(255,255,255,0.1)] not-prose text-[0.8125rem] pl-4 pb-4"><div class="flex "><pre highlighter="hljs"><code class="language-typescript"><span>import</span><span> { customAlphabet } </span><span>from</span><span> </span><span>"nanoid"</span><span>;
</span><span></span><span>export</span><span> </span><span>const</span><span> nanoid = customAlphabet(
</span><span>  </span><span>"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"</span><span>,
</span>);

<span></span><span>const</span><span> prefixes = {
</span><span>  </span><span>key</span><span>: </span><span>"key"</span><span>,
</span><span>  </span><span>api</span><span>: </span><span>"api"</span><span>,
</span><span>  </span><span>policy</span><span>: </span><span>"pol"</span><span>,
</span><span>  </span><span>request</span><span>: </span><span>"req"</span><span>,
</span><span>  </span><span>workspace</span><span>: </span><span>"ws"</span><span>,
</span><span>  </span><span>keyAuth</span><span>: </span><span>"key_auth"</span><span>, </span><span>// &lt;-- this is internal and does not need to be short or pretty</span><span>
</span><span>  </span><span>vercelBinding</span><span>: </span><span>"vb"</span><span>,
</span><span>  </span><span>test</span><span>: </span><span>"test"</span><span>, </span><span>// &lt;-- for tests only</span><span>
</span><span>} </span><span>as</span><span> </span><span>const</span><span>;
</span>
<span></span><span>export</span><span> </span><span class="hljs-function">function</span><span class="hljs-function"> </span><span class="hljs-function">newId</span><span class="hljs-function">(</span><span class="hljs-function">prefix: keyof </span><span class="hljs-function">typeof</span><span class="hljs-function"> prefixes</span><span class="hljs-function">): </span><span class="hljs-function">string</span><span class="hljs-function"> </span><span>{
</span><span>  </span><span>return</span><span> [prefixes[prefix], nanoid(</span><span>16</span><span>)].join(</span><span>"_"</span><span>);
</span>}</code></pre></div></div>
<p class="text-lg font-normal leading-8 text-left text-white/60">And when we use it in our codebase, we can ensure that we always use the correct prefix for the correct type of id.</p>
<div class="flex flex-col bg-gradient-to-t from-[rgba(255,255,255,0.1)] to-[rgba(255,255,255,0.07)] rounded-[20px] border-[.5px] border-[rgba(255,255,255,0.1)] not-prose text-[0.8125rem] pl-4 pb-4"><div class="flex "><pre highlighter="hljs"><code class="language-typescript"><span>import</span><span> { newId } </span><span>from</span><span> </span><span>"@unkey/id"</span><span>;
</span>
<span></span><span>const</span><span> id = newId(</span><span>"workspace"</span><span>);
</span><span></span><span>// ws_dYuyGV3qMKvebjML</span><span>
</span>
<span></span><span>const</span><span> id = newId(</span><span>"keyy"</span><span>);
</span><span></span><span>// invalid because `keyy` is not a valid prefix name</span></code></pre></div></div>
<hr>
<p class="text-lg font-normal leading-8 text-left text-white/60">I've been mostly talking about identifiers here, but an api key really is just an identifier too. It's just a special kind of identifier that is used to authenticate requests. We use the same strategies for our api keys as we do for our identifiers. You can add a prefix to let your users know what kind of key they are looking at and you can specify the length of the key within reason.
Colissions for API keys are much more serious than ids, so we enforce secure limits.</p>
<p class="text-lg font-normal leading-8 text-left text-white/60">It's quite common to prefix your API keys with something that identifies your company. For example <a href="https://resend.com" aria-label="Link" class="text-left text-white underline hover:text-white/60">Resend</a> are using <code class="px-2 py-1 font-medium text-gray-600 border border-gray-200 rounded-md bg-gray-50 before:hidden after:hidden">re_</code> and <a href="https://openstatus.dev" aria-label="Link" class="text-left text-white underline hover:text-white/60">OpenStatus</a> are using <code class="px-2 py-1 font-medium text-gray-600 border border-gray-200 rounded-md bg-gray-50 before:hidden after:hidden">os_</code> prefixes. This allows your users to quickly identify the key and know what it's used for.</p>
<div class="flex flex-col bg-gradient-to-t from-[rgba(255,255,255,0.1)] to-[rgba(255,255,255,0.07)] rounded-[20px] border-[.5px] border-[rgba(255,255,255,0.1)] not-prose text-[0.8125rem] pl-4 pb-4"><div class="flex "><pre highlighter="hljs"><code class="language-typescript"><span>const</span><span> key = </span><span>await</span><span> unkey.key.create({
</span><span>  </span><span>apiId</span><span>: </span><span>"api_dzeBEZDwJ18WyD7b"</span><span>,
</span><span>  </span><span>prefix</span><span>: </span><span>"blog"</span><span>,
</span><span>  </span><span>byteLength</span><span>: </span><span>16</span><span>,
</span><span>  </span><span>// ... omitted for brevity</span><span>
</span>});

<span></span><span>// Created key:</span><span>
</span><span></span><span>// blog_cLsvCvmY35kCfchi</span></code></pre></div></div></div></div></body></html>